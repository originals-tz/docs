此处记录开发中的调试过程

### #0
服务A是一个需要加载大量数据的服务，在数据时需要大量内存

为了降低内存峰值，需要将A，B流程错开，由于A，B流程需要前置数据

因此整个流程如下

```
收到数据下载信号 -> 执行A -> 执行B
```

A，B的内存峰值都会在10G以上

重构之后，稳态内存不降反升，排查后发现有以下原因
- 下载信号频繁触发，A，B会频繁执行
- 由于A，B频繁执行，tcmalloc会将内存一直缓冲

根据以上原因，将流程重构为

- 只在特定时间响应下载信号，减少A，B的执行频率

### #1
服务A使用了自己实现的一套有栈协程，近期出现**随机coredump**的情况

由于使用动态库的形式，无法触发协程中的assert

开启源码编译后，发现协程中的assert被触发，**一个枚举被置为无效值**

因此可以确定内存越界了 (随机崩溃+枚举无效值)，通过**typeinfo**定位到崩溃的业务协程

在使用二分法找到引发崩溃的地方，发现是最近调整了配置文件读取函数中的数组大小超过了协程栈的大小，引发越界

### #2
服务A需要发送HTTP请求，在测试环境发送没有问题，在生产坏境发送返回了

`Request Header or Cookie Too Large`

调试后发现是配置文件读取函数中，使用string作为buffer

```cpp
string read_conf()
{
	string buf(1024, '\0');
	...
	res = buf
}
```

使用这个函数读取配置文件中的账号密码，然后编码为base64时，导致`\0`也被编码了，超过了http头的长度 


